 PR#1 驗證

 # 單元測試
 go test ./internal/mdns/...
 go test ./internal/device/...

 PR#2 驗證

 # 啟動服務
 ./discover

 # 使用 avahi-browse 驗證 mDNS 廣播
 avahi-browse -rt _arx-discover._tcp

 # 應該看到本機設備的 TXT records：
 # device_id=xxx
 # model_name=xxx
 # cpu_cores=8
 # memory=16GB
 # ...

 PR#3 驗證

 # 使用 grpcurl 測試 Discover RPC
 grpcurl -unix -plaintext \
   -d '{"timeout": "10s"}' \
   /var/run/arx/node-discovery.sock \
   arx.node.v1.DiscoveryService/Discover

 # 應該看到 streaming 回傳的設備清單

  ---
 七、關鍵決策說明

 為何保留 mdns.Server？

 - 抽象層次清晰：Manager → Server → Service → Advertiser/Scanner
 - 未來擴展性：可在 Server 層加入健康檢查、metrics 等
 - 單一責任：Server 管理生命週期，Service 管理業務邏輯

 為何 Service 不拉出去？

 - mdns package 已經職責清晰
 - Service 就是為了協調 Advertiser 和 Scanner
 - 無需過度設計

 Manager.Start() 如何確保 mDNS 啟動成功？

 - 新增 startup synchronization channel
 - 等待 mDNS 啟動成功（2秒 timeout）
 - 立即返回錯誤如果啟動失敗
 - 確保不會返回成功但實際服務未運行

 ---
 這個規劃確保：
 ✅ 功能完整（Advertiser + Scanner 都實現）
 ✅ 架構清晰（層次分明，職責單一）
 ✅ 可測試性高（單元測試 + 整合測試）
 ✅ PR 切分合理（按功能模組分離）
 ✅ Commit 粒度適中（每個 commit 可獨立編譯）